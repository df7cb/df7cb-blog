<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>PostgreSQL and Undelete | Myon&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="pg_dirtyread
Earlier this week, I updated pg_dirtyread
to work with PostgreSQL 14.
pg_dirtyread is a PostgreSQL extension that allows reading &ldquo;dead&rdquo; rows from
tables, i.e. rows that have already been deleted, or updated. Of course that
works only if the table has not been cleaned-up yet by a VACUUM command or
autovacuum, which is PostgreSQL&rsquo;s garbage collection machinery.
Here&rsquo;s an example of pg_dirtyread in action:
# create table foo (id int, t text);
CREATE TABLE
# insert into foo values (1, &#39;Doc1&#39;);
INSERT 0 1
# insert into foo values (2, &#39;Doc2&#39;);
INSERT 0 1
# insert into foo values (3, &#39;Doc3&#39;);
INSERT 0 1

# select * from foo;
 id │  t
────┼──────
  1 │ Doc1
  2 │ Doc2
  3 │ Doc3
(3 rows)

# delete from foo where id &lt; 3;
DELETE 2

# select * from foo;
 id │  t
────┼──────
  3 │ Doc3
(1 row)
Oops! The first two documents have disappeared.
Now let&rsquo;s use pg_dirtyread to look at the table:
# create extension pg_dirtyread;
CREATE EXTENSION

# select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text);
 id │  t
────┼──────
  1 │ Doc1
  2 │ Doc2
  3 │ Doc3
All three documents are still there, but only one of them is visible.
pg_dirtyread can also show PostgreSQL&rsquo;s system colums with the row location and
visibility information. For the first two documents, xmax is set, which means
the row has been deleted:
# select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text);
 ctid  │ xmin │ xmax │ id │  t
───────┼──────┼──────┼────┼──────
 (0,1) │ 1577 │ 1580 │  1 │ Doc1
 (0,2) │ 1578 │ 1580 │  2 │ Doc2
 (0,3) │ 1579 │    0 │  3 │ Doc3
(3 rows)
Undelete
Caveat: I&rsquo;m not promising any of the ideas quoted below will actually work in
practice. There are a few caveats and a good portion of intricate knowledge
about the PostgreSQL internals might be required to succeed properly. Consider
consulting your favorite PostgreSQL support channel for advice if you need to
recover data on any production system. Don&rsquo;t try this at work.
I always had plans to extend pg_dirtyread to include some &ldquo;undelete&rdquo; command to
make deleted rows reappear, but never got around to trying that. But rows can already be
restored by using the output of pg_dirtyread itself:
# insert into foo select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text) where id = 1;
This is not a true &ldquo;undelete&rdquo;, though - it just inserts new rows from the data
read from the table.
pg_surgery
Enter pg_surgery,
which is a new PostgreSQL extension supplied with PostgreSQL 14. It contains
two functions to &ldquo;perform surgery on a damaged relation&rdquo;. As a side-effect,
they can also make delete tuples reappear.
As I discovered now, one of the functions, heap_force_freeze(), works nicely
with pg_dirtyread. It takes a list of ctids (row locations) that it marks
&ldquo;frozen&rdquo;, but at the same time as &ldquo;not deleted&rdquo;.
Let&rsquo;s apply it to our test table, using the ctids that pg_dirtyread can read:
# create extension pg_surgery;
CREATE EXTENSION

# select heap_force_freeze(&#39;foo&#39;, array_agg(ctid))
    from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text) where id = 1;
 heap_force_freeze
───────────────────

(1 row)
Et voilà, our deleted document is back:">
    <meta name="generator" content="Hugo 0.152.2">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="Christoph Berg">
    

    
<link rel="stylesheet" href="/blog/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://df7cb.de/blog/posts/2021/postgresql-undelete.html">
    

    <meta property="og:url" content="https://df7cb.de/blog/posts/2021/postgresql-undelete.html">
  <meta property="og:site_name" content="Myon&#39;s Blog">
  <meta property="og:title" content="PostgreSQL and Undelete">
  <meta property="og:description" content="pg_dirtyread Earlier this week, I updated pg_dirtyread to work with PostgreSQL 14. pg_dirtyread is a PostgreSQL extension that allows reading “dead” rows from tables, i.e. rows that have already been deleted, or updated. Of course that works only if the table has not been cleaned-up yet by a VACUUM command or autovacuum, which is PostgreSQL’s garbage collection machinery.
Here’s an example of pg_dirtyread in action:
# create table foo (id int, t text); CREATE TABLE # insert into foo values (1, &#39;Doc1&#39;); INSERT 0 1 # insert into foo values (2, &#39;Doc2&#39;); INSERT 0 1 # insert into foo values (3, &#39;Doc3&#39;); INSERT 0 1 # select * from foo; id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 (3 rows) # delete from foo where id &lt; 3; DELETE 2 # select * from foo; id │ t ────┼────── 3 │ Doc3 (1 row) Oops! The first two documents have disappeared.
Now let’s use pg_dirtyread to look at the table:
# create extension pg_dirtyread; CREATE EXTENSION # select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text); id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 All three documents are still there, but only one of them is visible.
pg_dirtyread can also show PostgreSQL’s system colums with the row location and visibility information. For the first two documents, xmax is set, which means the row has been deleted:
# select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text); ctid │ xmin │ xmax │ id │ t ───────┼──────┼──────┼────┼────── (0,1) │ 1577 │ 1580 │ 1 │ Doc1 (0,2) │ 1578 │ 1580 │ 2 │ Doc2 (0,3) │ 1579 │ 0 │ 3 │ Doc3 (3 rows) Undelete Caveat: I’m not promising any of the ideas quoted below will actually work in practice. There are a few caveats and a good portion of intricate knowledge about the PostgreSQL internals might be required to succeed properly. Consider consulting your favorite PostgreSQL support channel for advice if you need to recover data on any production system. Don’t try this at work.
I always had plans to extend pg_dirtyread to include some “undelete” command to make deleted rows reappear, but never got around to trying that. But rows can already be restored by using the output of pg_dirtyread itself:
# insert into foo select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text) where id = 1; This is not a true “undelete”, though - it just inserts new rows from the data read from the table.
pg_surgery Enter pg_surgery, which is a new PostgreSQL extension supplied with PostgreSQL 14. It contains two functions to “perform surgery on a damaged relation”. As a side-effect, they can also make delete tuples reappear.
As I discovered now, one of the functions, heap_force_freeze(), works nicely with pg_dirtyread. It takes a list of ctids (row locations) that it marks “frozen”, but at the same time as “not deleted”.
Let’s apply it to our test table, using the ctids that pg_dirtyread can read:
# create extension pg_surgery; CREATE EXTENSION # select heap_force_freeze(&#39;foo&#39;, array_agg(ctid)) from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text) where id = 1; heap_force_freeze ─────────────────── (1 row) Et voilà, our deleted document is back:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-11-18T11:21:51+01:00">
    <meta property="article:modified_time" content="2021-11-18T11:21:51+01:00">
    <meta property="article:tag" content="Debian">
    <meta property="article:tag" content="Postgresql">

  <meta itemprop="name" content="PostgreSQL and Undelete">
  <meta itemprop="description" content="pg_dirtyread Earlier this week, I updated pg_dirtyread to work with PostgreSQL 14. pg_dirtyread is a PostgreSQL extension that allows reading “dead” rows from tables, i.e. rows that have already been deleted, or updated. Of course that works only if the table has not been cleaned-up yet by a VACUUM command or autovacuum, which is PostgreSQL’s garbage collection machinery.
Here’s an example of pg_dirtyread in action:
# create table foo (id int, t text); CREATE TABLE # insert into foo values (1, &#39;Doc1&#39;); INSERT 0 1 # insert into foo values (2, &#39;Doc2&#39;); INSERT 0 1 # insert into foo values (3, &#39;Doc3&#39;); INSERT 0 1 # select * from foo; id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 (3 rows) # delete from foo where id &lt; 3; DELETE 2 # select * from foo; id │ t ────┼────── 3 │ Doc3 (1 row) Oops! The first two documents have disappeared.
Now let’s use pg_dirtyread to look at the table:
# create extension pg_dirtyread; CREATE EXTENSION # select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text); id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 All three documents are still there, but only one of them is visible.
pg_dirtyread can also show PostgreSQL’s system colums with the row location and visibility information. For the first two documents, xmax is set, which means the row has been deleted:
# select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text); ctid │ xmin │ xmax │ id │ t ───────┼──────┼──────┼────┼────── (0,1) │ 1577 │ 1580 │ 1 │ Doc1 (0,2) │ 1578 │ 1580 │ 2 │ Doc2 (0,3) │ 1579 │ 0 │ 3 │ Doc3 (3 rows) Undelete Caveat: I’m not promising any of the ideas quoted below will actually work in practice. There are a few caveats and a good portion of intricate knowledge about the PostgreSQL internals might be required to succeed properly. Consider consulting your favorite PostgreSQL support channel for advice if you need to recover data on any production system. Don’t try this at work.
I always had plans to extend pg_dirtyread to include some “undelete” command to make deleted rows reappear, but never got around to trying that. But rows can already be restored by using the output of pg_dirtyread itself:
# insert into foo select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text) where id = 1; This is not a true “undelete”, though - it just inserts new rows from the data read from the table.
pg_surgery Enter pg_surgery, which is a new PostgreSQL extension supplied with PostgreSQL 14. It contains two functions to “perform surgery on a damaged relation”. As a side-effect, they can also make delete tuples reappear.
As I discovered now, one of the functions, heap_force_freeze(), works nicely with pg_dirtyread. It takes a list of ctids (row locations) that it marks “frozen”, but at the same time as “not deleted”.
Let’s apply it to our test table, using the ctids that pg_dirtyread can read:
# create extension pg_surgery; CREATE EXTENSION # select heap_force_freeze(&#39;foo&#39;, array_agg(ctid)) from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text) where id = 1; heap_force_freeze ─────────────────── (1 row) Et voilà, our deleted document is back:">
  <meta itemprop="datePublished" content="2021-11-18T11:21:51+01:00">
  <meta itemprop="dateModified" content="2021-11-18T11:21:51+01:00">
  <meta itemprop="wordCount" content="738">
  <meta itemprop="keywords" content="Debian,Postgresql">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="PostgreSQL and Undelete">
  <meta name="twitter:description" content="pg_dirtyread Earlier this week, I updated pg_dirtyread to work with PostgreSQL 14. pg_dirtyread is a PostgreSQL extension that allows reading “dead” rows from tables, i.e. rows that have already been deleted, or updated. Of course that works only if the table has not been cleaned-up yet by a VACUUM command or autovacuum, which is PostgreSQL’s garbage collection machinery.
Here’s an example of pg_dirtyread in action:
# create table foo (id int, t text); CREATE TABLE # insert into foo values (1, &#39;Doc1&#39;); INSERT 0 1 # insert into foo values (2, &#39;Doc2&#39;); INSERT 0 1 # insert into foo values (3, &#39;Doc3&#39;); INSERT 0 1 # select * from foo; id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 (3 rows) # delete from foo where id &lt; 3; DELETE 2 # select * from foo; id │ t ────┼────── 3 │ Doc3 (1 row) Oops! The first two documents have disappeared.
Now let’s use pg_dirtyread to look at the table:
# create extension pg_dirtyread; CREATE EXTENSION # select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text); id │ t ────┼────── 1 │ Doc1 2 │ Doc2 3 │ Doc3 All three documents are still there, but only one of them is visible.
pg_dirtyread can also show PostgreSQL’s system colums with the row location and visibility information. For the first two documents, xmax is set, which means the row has been deleted:
# select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text); ctid │ xmin │ xmax │ id │ t ───────┼──────┼──────┼────┼────── (0,1) │ 1577 │ 1580 │ 1 │ Doc1 (0,2) │ 1578 │ 1580 │ 2 │ Doc2 (0,3) │ 1579 │ 0 │ 3 │ Doc3 (3 rows) Undelete Caveat: I’m not promising any of the ideas quoted below will actually work in practice. There are a few caveats and a good portion of intricate knowledge about the PostgreSQL internals might be required to succeed properly. Consider consulting your favorite PostgreSQL support channel for advice if you need to recover data on any production system. Don’t try this at work.
I always had plans to extend pg_dirtyread to include some “undelete” command to make deleted rows reappear, but never got around to trying that. But rows can already be restored by using the output of pg_dirtyread itself:
# insert into foo select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text) where id = 1; This is not a true “undelete”, though - it just inserts new rows from the data read from the table.
pg_surgery Enter pg_surgery, which is a new PostgreSQL extension supplied with PostgreSQL 14. It contains two functions to “perform surgery on a damaged relation”. As a side-effect, they can also make delete tuples reappear.
As I discovered now, one of the functions, heap_force_freeze(), works nicely with pg_dirtyread. It takes a list of ctids (row locations) that it marks “frozen”, but at the same time as “not deleted”.
Let’s apply it to our test table, using the ctids that pg_dirtyread can read:
# create extension pg_surgery; CREATE EXTENSION # select heap_force_freeze(&#39;foo&#39;, array_agg(ctid)) from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text) where id = 1; heap_force_freeze ─────────────────── (1 row) Et voilà, our deleted document is back:">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/blog/index.html" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Myon&#39;s Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">PostgreSQL and Undelete</h1>
      
      <p class="tracked"><strong>Christoph Berg</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-11-18T11:21:51+01:00">November 18, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="pg_dirtyread">pg_dirtyread</h2>
<p>Earlier this week, I updated <a href="https://github.com/df7cb/pg_dirtyread">pg_dirtyread</a>
to work with <a href="https://www.postgresql.org/docs/14/index.html">PostgreSQL 14</a>.
pg_dirtyread is a PostgreSQL extension that allows reading &ldquo;dead&rdquo; rows from
tables, i.e. rows that have already been deleted, or updated. Of course that
works only if the table has not been cleaned-up yet by a VACUUM command or
autovacuum, which is PostgreSQL&rsquo;s garbage collection machinery.</p>
<p>Here&rsquo;s an example of pg_dirtyread in action:</p>
<pre tabindex="0"><code># create table foo (id int, t text);
CREATE TABLE
# insert into foo values (1, &#39;Doc1&#39;);
INSERT 0 1
# insert into foo values (2, &#39;Doc2&#39;);
INSERT 0 1
# insert into foo values (3, &#39;Doc3&#39;);
INSERT 0 1

# select * from foo;
 id │  t
────┼──────
  1 │ Doc1
  2 │ Doc2
  3 │ Doc3
(3 rows)

# delete from foo where id &lt; 3;
DELETE 2

# select * from foo;
 id │  t
────┼──────
  3 │ Doc3
(1 row)
</code></pre><p>Oops! The first two documents have disappeared.</p>
<p>Now let&rsquo;s use pg_dirtyread to look at the table:</p>
<pre tabindex="0"><code># create extension pg_dirtyread;
CREATE EXTENSION

# select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text);
 id │  t
────┼──────
  1 │ Doc1
  2 │ Doc2
  3 │ Doc3
</code></pre><p>All three documents are still there, but only one of them is visible.</p>
<p>pg_dirtyread can also show PostgreSQL&rsquo;s system colums with the row location and
visibility information. For the first two documents, xmax is set, which means
the row has been deleted:</p>
<pre tabindex="0"><code># select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text);
 ctid  │ xmin │ xmax │ id │  t
───────┼──────┼──────┼────┼──────
 (0,1) │ 1577 │ 1580 │  1 │ Doc1
 (0,2) │ 1578 │ 1580 │  2 │ Doc2
 (0,3) │ 1579 │    0 │  3 │ Doc3
(3 rows)
</code></pre><h2 id="undelete">Undelete</h2>
<p><strong>Caveat:</strong> <em>I&rsquo;m not promising any of the ideas quoted below will actually work in
practice. There are a few caveats and a good portion of intricate knowledge
about the PostgreSQL internals might be required to succeed properly. Consider
consulting your favorite PostgreSQL support channel for advice if you need to
recover data on any production system.</em> <strong>Don&rsquo;t try this at work.</strong></p>
<p>I always had plans to extend pg_dirtyread to include some &ldquo;undelete&rdquo; command to
make deleted rows reappear, but never got around to trying that. But rows can already be
restored by using the output of pg_dirtyread itself:</p>
<pre tabindex="0"><code># insert into foo select * from pg_dirtyread(&#39;foo&#39;) t(id int, t text) where id = 1;
</code></pre><p>This is not a true &ldquo;undelete&rdquo;, though - it just inserts new rows from the data
read from the table.</p>
<h2 id="pg_surgery">pg_surgery</h2>
<p>Enter <a href="https://www.postgresql.org/docs/current/pgsurgery.html">pg_surgery</a>,
which is a new PostgreSQL extension supplied with PostgreSQL 14. It contains
two functions to &ldquo;perform surgery on a damaged relation&rdquo;. As a side-effect,
they can also make delete tuples reappear.</p>
<p>As I discovered now, one of the functions, heap_force_freeze(), works nicely
with pg_dirtyread. It takes a list of ctids (row locations) that it marks
&ldquo;frozen&rdquo;, but at the same time as &ldquo;not deleted&rdquo;.</p>
<p>Let&rsquo;s apply it to our test table, using the ctids that pg_dirtyread can read:</p>
<pre tabindex="0"><code># create extension pg_surgery;
CREATE EXTENSION

# select heap_force_freeze(&#39;foo&#39;, array_agg(ctid))
    from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text) where id = 1;
 heap_force_freeze
───────────────────

(1 row)
</code></pre><p>Et voilà, our deleted document is back:</p>
<pre tabindex="0"><code># select * from foo;
 id │  t
────┼──────
  1 │ Doc1
  3 │ Doc3
(2 rows)

# select * from pg_dirtyread(&#39;foo&#39;) t(ctid tid, xmin xid, xmax xid, id int, t text);
 ctid  │ xmin │ xmax │ id │  t
───────┼──────┼──────┼────┼──────
 (0,1) │    2 │    0 │  1 │ Doc1
 (0,2) │ 1578 │ 1580 │  2 │ Doc2
 (0,3) │ 1579 │    0 │  3 │ Doc3
(3 rows)
</code></pre><h2 id="disclaimer">Disclaimer</h2>
<p>Most importantly, none of the above methods will work if the data you just
deleted has already been purged by VACUUM or autovacuum. These actively zero
out reclaimed space. Restore from backup to get your data back.</p>
<p>Since both pg_dirtyread and pg_surgery operate outside the normal PostgreSQL
MVCC machinery, it&rsquo;s easy to create corrupt data using them. This includes
duplicated rows, duplicated primary key values, indexes being out of sync with
tables, broken foreign key constraints, and others. <em>You have been warned.</em></p>
<p>pg_dirtyread does not work (yet) if the deleted rows contain any
<a href="https://www.postgresql.org/docs/current/storage-toast.html">toasted</a>
values. Possible other approaches include using
<a href="https://www.postgresql.org/docs/current/pageinspect.html">pageinspect</a>
and <a href="https://wiki.postgresql.org/wiki/Pg_filedump">pg_filedump</a>
to retrieve the ctids of deleted rows.</p>
<p>Please make sure you have working backups and don&rsquo;t need any of the above.</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/blog/tags/debian.html" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Debian</a>
   </li>
  
   <li class="list di">
     <a href="/blog/tags/postgresql.html" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Postgresql</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/blog/posts/2020/arm64-on-apt.postgresql.org.html">arm64 on apt.postgresql.org</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2020/apt-archive.postgresql.org.html">Announcing apt-archive.postgresql.org</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2015/10_years_debian_developer.html">10 Years Debian Developer</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2015/postgresql_9.5_in_debian.html">PostgreSQL 9.5 in Debian</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2015/apt.postgresql.org_statistics.html">apt.postgresql.org statistics</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2014/postgresql_9.4_on_debian.html">PostgreSQL 9.4 on Debian</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2014/trusty_and_saucy_on_apt.postgresql.org.html">Trusty and Saucy on apt.postgresql.org</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2013/how_not_to_monitor_a_boolean.html">How not to monitor a boolean</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2013/postgresql_minor_releases.html">PostgreSQL minor releases</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2012/apt.postgresql.org.html">apt.postgresql.org</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2012/pgbouncer_running_on_the_same_hardware.html">pgbouncer running on the same hardware</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2012/shared_memory_and_swapping.html">Shared Memory and Swapping</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2012/postgresql_in_debian_hackathon.html">PostgreSQL in Debian Hackathon</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2011/postgresql_in_debian.html">PostgreSQL in Debian</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/posts/2018/paste.html">Cool Unix Features: paste</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://df7cb.de/blog/index.html" >
    &copy;  Myon's Blog 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
